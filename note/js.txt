js之可迭代对象
遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。
string也属于可迭代
///////////////////////
JavaScript中只有6个假值：
undefined
null
NaN
0
'' (empty string)
false
函数构造函数，如new Number和new Boolean都是真值。
///////////////////////////
闭包：
函数执行的一瞬间叫闭包，当执行后返回的结果必须是引用数据类型，被外界变量接收，此时函数不会被销毁
一个典型的闭包
let a = function(b){ 
     return function(c){
        return b+c
     } 
}
/////////////////////////
类数组
伪数组也叫类数组就是一个对象，但是跟数组一样，伪数组也会有length属性，也有0，1，2，3等属性
伪数组并没有数组的方法，不能使用push/pop等数组方法
伪数组可以和数组一样进行遍历
常见的伪数组：arguments、document.querySelectorAll的返回值、jquery对象

创建一个伪数组：
var obj = {
  0:"小黄",
  1:"小白",
  2:"小花",
  length:3
};
如果要用数组方法操作伪数组需要用call或者apply改变this到伪数组上操作
[].push.call(obj,"大黑")
//////////////////////
改变this指向：
1.apply,call 
2.bind 
3.箭头函数 ()=>{} 箭头函数自身没有this 用的是外层的this

call，apply 借用 修改this的指向
call,apply作用：
1.调用函数
function fn(){
  console.log(123)
}
fn.call();//123
fn.apply();//123
2.传递参数
function sum(x,y){
  console.log(x+y)
}
sum.call(null,2,3)//5
sum.apply(null,[2,3])//5
3.修改this指向
var obj = {
  name:"huwei",
  age:22
}
function sum(x,y){
  console.log(x+y);
  console.log(this.name);
  console.log(this.age);
}
sum(2,3)//5, ,undefined  函数直接执行时this指向window window.name是一个空值  window.age不存在undefined
sum.call(obj,2,3)//5,huwei,22  call把sum的this指向了obj sum里其他的逻辑还是原来的；
4.借用对象方法
var obj = {
  0:"大黄",
  1:"小白",
  length:2,
};//一个伪数组

[].push.call(obj,"小花");//借用了Array上的push方法
console.log(obj) //{0: "大黄", 1: "小白", 2: "小花", length: 3}

总结：call,apply 处理函数时，可以调用函数，向函数传递参数，改变函数this的指向；
     call,apply 处理对象object的时候，可以借用对象上的方法 把对象上的方法借给其他对象来使用
     call和apply用法基本一致，区别只在于call是把每个参数一个一个传入，apply是传入数组或伪数组
                参数不多的时候用call，参数多的时候用apply
///////////////////////////////////
bind是创建一个新的函数，可以绑定新的函数this指向，不会来调用函数
    常用来处理函数的this改变 
    bind只是处理函数this指向并返回一个新函数  不会立即执行这个新函数！！！
    而call改变this指向的同时 立即执行了函数
var fn = function(){
  console.log(this)
}
var fn2 = fn.bind([1,2,3])
console.log(fn2)//ƒ (){console.log(this)}
console.log(fn===fn2)//false  虽然fn和fn2长得一样 但是他们的引用指向是不一样的，所以是不同的函数
fn2()//[1,2,3]  bind把函数的this指向了数组[1,2,3]

改变setTimeout 里的this指向
var obj = {
  name:'huwei',
  age:12,
  hi:function(){
    setTimeout(function(){
      console.log(this.name)
    }.bind(this),1000)
  }
}
obj.hi()
/***************************************/
es6新关键字
yield
使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。
yield关键字实际返回一个IteratorResult（迭代器）对象，它有两个属性，value和done，分别代表返回值和是否完成。
yield无法单独工作，需要配合generator(生成器)的其他函数，如next，懒汉式操作，展现强大的主动控制特性。

next()驱动生成的函数，yield会让循环停在yield的地方 得到这个yield后面的值 输出成一个对象{'value':xx,'done':xx}
只有当函数内部不再有yield时 done才会显示true 表示执行完成  如果在继续next()驱动  也可以输出 {'value':undefined,done:true}
next(XX)驱动里赋值  时赋给了整个yield  不是函数的参数  

例子：
function* test(x){//function后要跟一个星号
  var y = 2*(yield(x+1))
  var z = yield(y/3)
  console.log('x:'+x,'y:'+y,'z:'+z)
  return (x+y+z)
}
var app = test(5);
console.log(app.next())//第一次停在yield(x+1) 所以结果是{value: 6, done: false}
console.log(app.next(12))//第二次next传入一个值  这个值替代 上一次yield整个的值  那么y=2*12=24 
                         //然后停在了yield(y/3)这里  所以输出{value:8,done:false}
console.log(app.next(13))//第三次next传入的值  替代 yield(y/3)  所以z=13 ,前面得到y = 24, x=5
                         //x+y+z = 5+24+13 = 42 return出42

/***************************************/
Promise.all和Promise.race
一、Pomise.all的使用
Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。
let p1 = new Promise((resolve, reject) => {
  resolve('成功了')
})

let p2 = new Promise((resolve, reject) => {
  resolve('success')
})

let p3 = Promse.reject('失败')

Promise.all([p1, p2]).then((result) => {
  console.log(result)               //['成功了', 'success']
}).catch((error) => {
  console.log(error)
})

Promise.all([p1,p3,p2]).then((result) => {
  console.log(result)
}).catch((error) => {
  console.log(error)      // 失败了，打出 '失败'
})
Promse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。

Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。
let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  },1000)
})

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('failed')
  }, 500)
})

Promise.race([p1, p2]).then((result) => {
  console.log(result)
}).catch((error) => {
  console.log(error)  // 打开的是 'failed'
})
/***************************************/
[1, 2, 3].map(num => {  
  if (typeof num === "number") return;  
  return num * 2; 
});//[undefined,undefined,undefined]
map映射循环时 如果返回时空 默认是undefined
/***************************************/
class Dog { 
  constructor(name) { 
    this.name = name; 
  } 
} 
Dog.prototype.bark = function() { 
  console.log(`Woof I am ${this.name}`);  
};  
const pet = new Dog("Mara");  
pet.bark(); //Woof I am Mara
delete Dog.prototype.bark;  
pet.bark(); //TypeError
我们可以用 delete关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了
delete操作符返回一个布尔值：true指删除成功，否则返回 false. 
但是通过 var, const 或 let 关键字声明的变量无法用 delete 操作符来删除。

/***************************************/
Set(注意大些首字母)
Set是ES6新的数据结构，类似数组，但成员的值是唯一的，没有重复的值。
/***************************************/
const settings = {  
  username: "lydiahallie",  
  level: 19,  
  health: 90  
};  
const data = JSON.stringify(settings, ["level", "health"]); 
console.log(data);//"{"level":19, "health":90}"
JSON.stringify的第二个参数是 替代者(replacer). 替代者(replacer)可以是个函数或数组，用以控制哪些值如何被转换为字符串。
/**************************************/
let num = 10; 
const increaseNumber = () => num++; 
const increasePassedNumber = number => number++;  
const num1 = increaseNumber();  
const num2 = increasePassedNumber(num1);  
console.log(num1);//10
console.log(num2);//10
一元操作符 ++ 先返回 操作值, 再累加 操作值。

/************************************/
const name = "Lydia Hallie" 
console.log(name.padStart(13))  
console.log(name.padStart(2))
使用 padStart方法，我们可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串 LydiaHallie的长度为 12, 因此 name.padStart（13）在字符串的开头只会插入1（ 13-12=1）个空格。

如果传递给 padStart方法的参数小于字符串的长度，则不会添加填充。
/**********************************/
console.log(String.raw`Hello\nworld`);
String.raw函数是用来获取一个模板字符串的原始字符串的，它返回一个字符串，其中忽略了转义符（ \n， \v， \t等）。但反斜杠可能造成问题，因为你可能会
/**********************************/
async function getData() {  
  return await Promise.resolve("I made it!"); 
} 
const data = getData(); 
console.log(data);
异步函数始终返回一个promise。 await仍然需要等待promise的解决：当我们调用 getData()并将其赋值给 data，此时 data为 getData方法返回的一个挂起的promise，该promise并没有解决。
如果我们想要访问已解决的值 "I made it!"，可以在 data上使用 .then()方法：
data.then(res=>console.log(res))
这样将打印 "I made it!"
/********************************/
function addToList(item, list) {  
  return list.push(item); 
} 
const result = addToList("apple", ["banana"]);  
console.log(result);//2
push()方法返回新数组的长度。一开始，数组包含一个元素（字符串 "banana"），长度为1。 在数组中添加字符串 "apple"后，长度变为2，并将从 addToList函数返回。
push方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在push item之后返回 list。
/*******************************/
使用 &&运算符，如果左侧值是真值，则返回右侧值。在这种情况下，左侧值 []是一个真值，所以返回 Im。
使用 ||运算符，我们可以返回第一个真值。如果所有值都是假值，则返回最后一个值。
/******************************/
Array.from()可以通过以下方式来创建数组对象：
伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）
可迭代对象（可以获取对象中的元素,如 Map和 Set 等）

数组去重最简单的方法--用new Set(arr) 过滤重复的， 然后在用Array.from(set) 转化成数组或者用展开[...set]
Array.from(1)//[]
Array.from({age:11})//[]
Array.from(undefined)//报错
Array.from(null)//报错
Array.from(NaN)//[]
Array.from(false)/Array.from(true) //[]
Array.from('foo')//['f','o','o']
/******************************/
Symbol
es6新的数据类型
var s = Symbol()
var s2 = Symbol()
console.log(s===s2)//false  不会重复
var age_sy = Symbol()
var obj = {"name":"huwei",[s]:11} //可以作为object的key
obj[age_sy] = 12;//object的key
console.log(obj) //{name: "huwei", Symbol(): 11, Symbol(): 12}
console.log(Object.keys(obj))//Symbol定义的key value 不会被 Object.keys() 或 for in  for of 获取
console.log(obj[s])//11
var str = JSON.stringify(obj); 
console.log(str)//{"name":"huwei"}
console.log(Object.getOwnPropertySymbols(obj))//可以被自带的getOwnPorpertySymbols方法获取
应用环境：
可以让对象有私有的属性  不会被外界循环 ，也可以定义一个变量保证他不会重复

/*****************************/
set
Set是ES6新的数据结构，类似数组，但成员的值是唯一的，没有重复的值。
（1）生成一个Set，添加重复值会被过滤掉
 (2）接收一个数组用来初始化 去除数组的重复成员
 注意，在Set内部，两个NaN相等，所以会去除重复的NaN，但是 === 是认为两个 NaN是不等的（NaN===NaN 结果是false）。
 add() //增
 set.add('huwei')
delete() //删
set.delete(1)//删除值是1的项
has() //是否存在
set.has(2)//判断存不存在值为2的项  返回一个布尔值

用for of 循环  用Array.from(set)转化成数组   也可以用展开 [...set]
。。。。。。。。。。。。。。。。。
map
新的数据结构与set类似 map传入参数是一个多维的数组
var maps = new Map([["name","huwei"]])
set//增加
maps.set("age",18)
get//获取
maps.get("name")
delete//删除
maps.delete("name")
for of循环遍历
for (var val of maps){
  console.log(Object.prototype.toString.call(val));//得到是数组类型 ["name","huwei"]
}
/*******************************/
关于隐式转换
会自动转化的
1. 转成string类型： +（字符串连接符） object[](对象的key)
2.转成number类型：++/--(自增自减运算符) + - * / %(算术运算符) > < >= <= == !=  
3. 转成boolean类型：!（逻辑非运算符）

const a = {};
const b = { key: "b" };
const c = { key: "c" };
a[b] = 123;
a[c] = 456;
console.log(a[b]);
我们试图将一个对象设置为对象a的键，其值为123 对象键自动转换为字符串。它变成了[Object object] a["Object object"] = 123
我们可以尝试再次做同样的事情那么，a["Object object"] = 456。我们打印a[b]，它实际上是a["Object object"]。 我们将其设置为456，因此返回456。
/*******************************/
*面向对象的继承方式

//1.原型链继承 用父类的实例来继承
//缺点：父类新增原型方法/原型属性，子类都能访问到，父类一变其它的都变了
// function person(name){
//   this.name = name;
// }
// person.prototype.getName = function(){
//   alert(this.name);
// }

// function parent(age){
//   this.age = age;
// }
// parent.prototype = new person('小明');
// parent.prototype.getAge = function(){
//   alert(this.age)
// }

// var result = new parent(22);
// result.getName();
// result.getAge();

//2.构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
// 缺点： 方法都在构造函数中定义， 只能继承父类的实例属性和方法，不能继承原型属性/方法，无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
// function person(name){
//   this.name = name;
//   this.friends = ['小红','小花']
//   this.getName = function(){
//     alert(this.name)
//   }
// }
// person.prototype.getFriends = function(){//这个在原型上的方法是无法继承到的
//   alert(this.friends)
// }

// function parent(age){
//   person.call(this,'老王');
//   this.age = age
// }
// parent.prototype.getAge = function(){
//   alert(this.age)
// }
// var result = new parent(22);
// result.getName()
// result.getAge()
// result.getFriends()
//3、组合继承   集合1，2继承方式的优点  一般采用这种方式来实现js的继承
// 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后再通过将父类实例作为子类原型，实现函数复用
// 缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
// function person(name){
//   this.name = name;
//   this.friends = ['小红','小花']
// }
// person.prototype.getName = function(){
//   alert(this.name);
// }

// function parent(age){
//   person.call(this,'老王')
//   this.age = age
// }
// parent.prototype = new person('老王')
// parent.prototype.getAge = function(){
//   alert(this.age)
// }

// var result = new person('小明')
// result.getName();
// result.friends.push('阿花');
// console.log(result.friends)

// var result1 = new parent(22);
// result1.getName();
// result1.getAge();
// console.log(result1.friends)
//4、寄生组合继承
// 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
// 缺点：堪称完美，但实现较为复杂
// function person(name){
//   this.name = name;
//   this.friends = ['小红','小花'];
// }
// person.prototype.getName = function(){
//   alert(this.name);
// }

// function parent(age){
//   person.call(this,'老王')
//   this.age = age
// }
// (function(){//自定义一个新的构造函数作为类似中间件，先用定义的原型指向父类的原型 这样新的原型上的就有父类原型
//            //然后子类原型指向这个新构造函数的实例  就完成了继承 避免了父类的二次实例化
//    var newObj = function(){}
//    newObj.prototype = person.prototype;
//    parent.prototype = new newObj();
// })()
// parent.prototype.getAge = function(){
//   alert(this.age)
// }

// var result = new parent(33);
// result.getName();
// result.getAge();

//es6对象继承方式
class person{
  constructor(name){//属性需要传的参数 写在constructor （）里
    this.name = name;
    this.friends = ['小红','小花']
    //constructor 里都是类的属性
  }
  //constructor 外写的是 类的方法  类似传统的prototype
  getName(){
    alert(this.name)
  }
}

class parent extends person {//通过extends 来继承父类
  constructor(name,age){//把父类需要的参数传进来 name
    super(name)//super相当于以前的call改变this指向  同时传入父类需要的参数 name
    this.age = age;
  }
  getAge(){
    alert(this.age)
  }
}

var test = new parent('小明',22);
test.getName();
test.getAge();
///////////////////////关于对象的继承补充知识
一个对象原型 function father(){...}
一个对象的实例  var f = new father()
实例上的 __proto__ 属性  对应的是  原型上的原型链  father.prototype
两者是同一个引用
f.__proto__ === father.prototype   => true;

实例的constructor 属性   对应的是  这个对象的原型
f.constructor === father   => true

**********************************************************************************
//es6解构***** 解构赋值可以把对象object 或 数组array  对应的变量里的某一对应项解构出某项的值
//解构会把数据隐式转换成对象或数组  然后进行解构操作 ---- undefined和null不可以会报错
/*数组的解构*/
//一般的解构赋值
var arr = [1,2,3,4]
var [a,b] = arr;
console.log(a);//1
console.log(b);//2
//复杂的结构赋值
var arr2 = [1,2,3,[4,5,[6]]]
var [, , ,[, ,[g]]] = arr2
console.log(g)//6
//与扩展符号...结合使用
//*扩展符
var arr3 = [1,2,3,4];
var arr4 = [5,6,7];
var narr = [...arr3,...arr4];
console.log(narr) //[1,2,3,4,5,6,7]

var arr5 = [1,2,3,4,5,6,7];
var [aa,bb,...cc] = arr5;
console.log(aa)//1
console.log(bb)//2
console.log(cc)//[3,4,5,6,7]
//可以给变量赋一个默认值
var arr6 = [1,undefined,undefined,2,null];
var [w,x=2,y,z=1,u=33] = arr6;
console.log(w)//1
console.log(x)//2
console.log(y)//undefined
console.log(z)//2
console.log(u)//null  null会被看作是一个对象 而覆盖默认值
//交换变量
let s = 12;
let sd = 15;
[s,sd] = [sd,s];
console.log(s);//15
console.log(sd);//12

/*对象的解构*/
//一般使用
var obj = {
  name:'小明',
  age:12
}
var {name,age} = obj;
console.log(name);//小明
console.log(age)//12
//复杂的例子
var obj1 = {
   status:'ok',
   data:[{
        username:'huwei',
        password:123456,
        nick:'yuki'
      },{
        username:'hw',
        password:33332,
        nick:'mavis'
      }]
}
var {data:[ass,{nick:uname}]} = obj1
console.log(ass);//{username:'huwei',password:123456,nick:'yuki'}
console.log(uname)//'mavis'
//结合扩展运算符
let obj2 = {
  id:1, name:'huwei',age:33
}
let {id:sid,...oth} = obj2
console.log(sid);//1
console.log(oth);//{name:"huwei",age:33}
//如何对已经申明了的变量进行对象的解构赋值
let ages;
const obj3 = {
    name:'小明',
    age:22
};
//{ ages } = obj3;    // 这样是会报错的，因为这里的{}被认为是一个块级作用域
({ ages } = obj3);  // <= 解决办法
console.log(ages)                // 不过，最好还是在声明的同时进行解构赋值如何对已经申明了的变量进行对象的解构赋值
// 默认值
let girlfriend = {
    gname: "小红",
    gage:22
};
let {gname="小明",gage,glike='游泳'} = girlfriend;
console.log(gname)//小红   如果解构值不是undefined,解构会覆盖默认值

/*解构字符串*/
const str = "I am the bone of my sword"; // 我是剑骨头
const [sa, sb, sc, ...soth] = str;
console.log(sa);     // "I"
console.log(sb);     // " "
console.log(sc);     // "a"
console.log(soth);   // ["m", " ", "t", "h", "e", " ", "b", "o", "n", "e", " ", 
                    // "o", "f", " ", "m", "y", " ", "s", "w", "o", "r", "d"]

//let {ats} = undefined//会报错  因为不能转成对象型数据进行解构
//let [ats] = null //会报错  因为不能转成对象型数据进行解构
//let [ats] = 6666//数字也会报错
//总结：只有三中数据形式可以进行解构操作：对象，数组，字符串
/***********************************************************************************************/
//let 和 const

在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围。
let增加了块级作用域
let不能像var一样变量提升，用let声明的变量，不存在变量提升。而且要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。
let不允许在相同作用域内，重复声明同一个变量。否则报错：Uncaught SyntaxError: Identifier 'XXX' has already been declared,var则可以，规则是同一作用域里，后命名的覆盖前面的
目的是让js代码更规范和安全

let表示声明变量，而const表示声明常量，两者都为块级作用域；const 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了：
const a = 1
a = 0 //报错
如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行：
const student = { name: 'cc' }

student.name = 'yy';// 不报错
student  = { name: 'yy' };// 报错
/**********************************************************************************************/
//模板字符串
在ES6之前，我们往往这么处理模板字符串：
通过“\”和“+”来构建模板
$("body").html("This demonstrates the output of HTML \
content to the page, including student's\
" + name + ", " + seatNumber + ", " + sex + " and so on.");

而对ES6来说

基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定；
ES6反引号(``)直接搞定
$("body").html(`This demonstrates the output of HTML content to the page, 
including student's ${name}, ${seatNumber}, ${sex} and so on.`);
/**********************************************************************************************/
//箭头函数（Arrow Functions）
ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体；

箭头函数最直观的三个特点。

1不需要 function 关键字来创建函数 x=>{alert(x)}  ====> function(x){alert(x)}
2省略 return 关键字  x=>x+1   ====>  function(x){return x+1}
3继承当前上下文的 this 关键字 自己没有this 会去上一层找this  解决一些回调中this指向了window的问题 例如setTimeout
4箭头函数没有prototype属性，返回undefined
/***********************************************************************************************/
//函数的参数默认值
// ES6之前，当未传入参数时，text = 'default'；
function printText(text) {
    text = text || 'default';
    console.log(text);
}

// ES6；
function printText(text = 'default') {
    console.log(text);
}

printText('hello'); // hello
printText();// default
/************************************************************************************************/
Spread / Rest 操作符
Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。
当被用于迭代器中时，它是一个 Spread 操作符：
function foo(x,y,z) {
  console.log(x,y,z);
}
 
let arr = [1,2,3];
foo(...arr); // 1 2 3
当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：
function foo(...args) {
  console.log(args);
}
foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
可以巧妙的获取argument数组
/**********************************************************************************************/
for … of循环是ES6引入的新的语法，用for … of循环遍历集合

for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义
var arr = [1,2,3]
for (var value of arr){
  console.log(value);
}//输出 1，2，3

for...in 循环
for...in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。

for (var key in arr){
  console.log(key);
}//输出 0，1，2
/**********************************************************************************************/
es6模块化
export 导出模块

import 引入模块

a.js
export let a = 1;

b.js
import {a} from './a.js'   a  /或者/ import * as b from './a.js'  b.a
as关键字
编程的同学对as都容易理解，简单的说就是取一个别名。export中可以用，import中其实可以用：

// a.js
var a = function() {};
export {a as fun};

// b.js
import {fun as a} from './a';
a();

默认导出  export default {a:1}

import any from './a.js'
any.a //1
/***********************************************************************************/
ECMAScript 5 为 JavaScript 添加了大量新的对象方法，如下
Object.defineProperty(object, property, descriptor) // 添加或更改对象属性 vue实现双向数据绑定的基础
//设置一般对象
var obj = {}
Object.defineProperty(obj,'name',{
     value:'huwei',
     writable:true,//是否可写入  默认false
     enumerable:true,//是否可出现在对象的枚举属性中 默认false
     configurable:true //是否允许改变或删除 默认false 

   }
})
//劫持写入（set） 读取（get） vue实现的基础 这样就可以知道对象什么时候插入了新数据  什么时候调用了数据，
这就是双向绑定的基础
defineProperty方法给对象添加了一个属性之后，属性默认为 不可枚举(not enumerable). 
var obj = {}
Object.defineProperty(obj,'name',{
     set(newval){//传入新赋的值
        console.log(newval)
        this.val = newval//在内部用一个属性记录值
     },
     get(v){
       return this.val//获取内部属性上的值 return 到外面调用
     } 
})
obj['name'] = 'huwei'
console.log(obj.name)
要注意的一点是：在 descriptor 中不能同时设置访问器（get 和 set）和 wriable 或 value，否则会错，就是说想用 get 和 set，就不能用 writable 或 value 中的任何一个。
//////////////////////////////////////////////
Object.defineProperties(object, descriptors) // 添加或更改多个对象属性
Object.values(obj)  //以数组返回所有可枚举的值
Object.keys(object) // 以数组返回所有可枚举的属性
Object.freeze(object) // 防止对对象进行任何更改
Object.isFrozen(object) // 如果对象被冻结，则返回 true
Object.getOwnPropertyDescriptor(object, property) // 访问属性
Object.getOwnPropertyNames(object) // 以数组返回所有属性
Object.create(object,[descriptors])  //以指定对象为原型创建新的对象

es6
Object.assign(obj1,obj2) //合并obj1,obj2对象 返回一个新的对象
Object.is(value1,value2) //value1 需要比较的第一个值value2 需要比较的第二个值
                           方法判断两个值是否是相同的值 不同于== 和=== 这个相同指的是完全相同
Object.keys()
Object.values()
/*********************************************************************************/
//vue实现原理代码
1.利用defineProperty重写对象 实现set和get时的劫持
var obj = {name:'huwei'}
observe(obj)
obj.name = 'yuki'//
console.log(obj.name)
function observe(obj){
  if(!obj||typeof obj !== 'object'){//如果不是对象就不需要继续了
    return 
  }
  Object.keys(obj).forEach(item=>{//循环 并重写
    defineReactive(obj,item,obj[item])
  })
}

function defineReactive(obj,key,val){//重写方法
   observe(val)//如果有自属性就会执行自属性重写
   Object.defineProperty(obj,key,{
       enumerable:true,
       configurable:false,
       get(){
         return val
       },
       set(newVal){
         console.log('改变了')
         val = newVal
       }
   })
}

/********************************************************************************/
//判断Array的6种办法
1. instanceof 操作符判断
用法：arr instanceof Array
instanceof 主要是用来判断某个实例是否属于某个对象
let arr = [];
console.log(arr instanceof Array); // true

2.对象构造函数的 constructor判断
用法：arr.constructor === Array
Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数
let arr = [];
console.log(arr.constructor === Array); // true

3.Array 原型链上的 isPrototypeOf
用法：Array.prototype.isPrototypeOf(arr)
Array.prototype  属性表示 Array 构造函数的原型
其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。
let arr = [];
console.log(Array.prototype.isPrototypeOf(arr)); // true

4.Object.getPrototypeOf
用法：Object.getPrototypeOf(arr) === Array.prototype
Object.getPrototypeOf() 方法返回指定对象的原型

所以只要跟Array的原型比较即可
let arr = [];
console.log(Object.getPrototypeOf(arr) === Array.prototype); // true

5.Object.prototype.toString
用法：Object.prototype.toString.call(arr) === '[object Array]'
虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。
let arr = [];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true

6.Array.isArray
用法：Array.isArray(arr)
ES5中新增了Array.isArray方法,IE8及以下不支持
let arr = [];
console.log(Array.isArray(arr)); // true

/*************************************************************************************/
//js中遍历数组的方法
1.第一种最常用的：for循环

 for(j = 0; j < arr.length; j++) {
    break;    //终止循环
    continue;  //跳过本次循环
    return; // return所在函数
  } //对于数组较大时，优化比较明显；
  //for循环只能遍历数组, 不能遍历对象.

2.第二种：foreach
arr.forEach(function(e){  
   
});
//forEach本身无法跳出所以循环，可采用将forEach放入try{},catch{},手动抛出异常的方式
//forEach无法遍历对象，低版本ie不支持
//forEach无法使用break，continue跳出循环，使用return时，效果和在for循环中使用continue一致

3.for ……in
var arr = new Array("first", "second", "third") 
for(var item in arr) {
document.write(arr[item]+",");
}//for……in 的效率比较低，for in主要用于遍历对象属性
//for...in 遍历数组的缺点：
数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。
for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
某些情况下，for…in循环会以任意顺序遍历键名。

4.map 遍历
arr.map(function(n){  
   
});//该方法只支持数组 map方法使用其提供函数的每次返回结果生成一个新的数组.

5.第五种：for……of 遍历（需要ES6支持）
for(let value of arr) {  
   
});
//es6 新推出的 for...of 循环方式，性能和 for 循环差不多，推荐使用 for...of 遍历数组和对象
for、map是比较常用的两种方法，性能也还行。
/**************************************************************************************/
//算法： 排序的几种方法
//冒泡排序
// function maopao(arr){
//   for (var i = 0; i<arr.length; i++){
//     for(var j=0; j<arr.length-1-i;j++){//因为每次冒泡都把最大放到最后了  所以第二次遍历 可以不用遍历后面的i项
//        if(arr[j]>arr[j+1]){
//           var temp = arr[j];
//           arr[j] = arr[j+1];
//           arr[j+1] = temp;
//        }
//     }
//   }
//   return arr
// }
//选择排序
// function selectSort(arr){
//   var minIndex,temp
//   for(var i = 0; i<arr.length;i++){
//       minIndex = i
//       for(var j=i;j<arr.length;j++){//寻找i以后的项
//          if(arr[j]<arr[minIndex]){//找出比当前i索引下的值小的j索引  保存到变量
//            minIndex = j
//          }
//       }
//       temp = arr[minIndex]; //把找到最小的j索引的值  替换 当前第i项   这样就保证每次都把最小的放到前面了
//       arr[minIndex] = arr[i];
//       arr[i] = temp
//   }
//   return arr
// } 
//插入排序（Insertion Sort）
// function insertionSort(arr) {
//   var preIndex,temp,len = arr.length;
//   for(var i=1;i<len;i++){
//      preIndex = i-1;
//      temp = arr[i];
//      while(preIndex>=0&&arr[preIndex]>temp){//进入循环的条件 前一项值大于当前项  
//        arr[preIndex+1] = arr[preIndex]     //就把当前项替换成前一项  
//        preIndex--    //然后继续查下一个是不是符合循环条件
//      }
//      arr[preIndex+1] = temp //跳出循环时的preIndex+1项是没有值的因为比temp大的都移到前面项去了把记录的temp填入
//   }
//   return arr

// } 

/******************************************************************************/
网络安全
1.XSS跨站脚本攻击
这是最常见的网络攻击案例，基本是防不胜防，首先说下XSS攻击网络原理，跨站脚本攻击。

XSS是常见的Web攻击技术之一.所谓的跨站脚本攻击指得是:恶意攻击者往Web页面里注入恶意Script代码，用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取cookie信息、会话劫持等各种攻击。
规避：
前端控制
结合一些行业大牛，和自己的一些亲身经历给出以下几点尽量避免被黑入
(1)一定要过滤用户的输入信息  禁止用户在输入的过程中输入"<",">","引号","$","_",这个为什么因该不需要我解释，网上大牛们说的很清楚，当然根据原理，你也能推测出来
(2)核心的用户身份标示或token保存在Cookie中,Cookie中一定要加“HTTPOnly”在结尾，保证只有在html操作时才能将cookie中的内容发送出去，在JS中无法获得用户的Cookie信息

2.CSRF网络攻击
CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。
规避：
目前规避这种网络攻击的最有效方式是减少在cookie 中存储客户核心内容比如用户的token、ID、access_token等，将和信息存在前端的storage中，对于认为使用session就万无一失的大佬们同样要注意，使用session并不能避免CSRF，只要完全的依赖cookie和session来进行用户校验的系统都可以轻松被CSRF攻破


