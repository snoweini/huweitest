*面向对象的继承方式

//1.原型链继承 用父类的实例来继承
//缺点：父类新增原型方法/原型属性，子类都能访问到，父类一变其它的都变了
// function person(name){
//   this.name = name;
// }
// person.prototype.getName = function(){
//   alert(this.name);
// }

// function parent(age){
//   this.age = age;
// }
// parent.prototype = new person('小明');
// parent.prototype.getAge = function(){
//   alert(this.age)
// }

// var result = new parent(22);
// result.getName();
// result.getAge();

//2.构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
// 缺点： 方法都在构造函数中定义， 只能继承父类的实例属性和方法，不能继承原型属性/方法，无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
// function person(name){
//   this.name = name;
//   this.friends = ['小红','小花']
//   this.getName = function(){
//     alert(this.name)
//   }
// }
// person.prototype.getFriends = function(){//这个在原型上的方法是无法继承到的
//   alert(this.friends)
// }

// function parent(age){
//   person.call(this,'老王');
//   this.age = age
// }
// parent.prototype.getAge = function(){
//   alert(this.age)
// }
// var result = new parent(22);
// result.getName()
// result.getAge()
// result.getFriends()
//3、组合继承   集合1，2继承方式的优点  一般采用这种方式来实现js的继承
// 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后再通过将父类实例作为子类原型，实现函数复用
// 缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
// function person(name){
//   this.name = name;
//   this.friends = ['小红','小花']
// }
// person.prototype.getName = function(){
//   alert(this.name);
// }

// function parent(age){
//   person.call(this,'老王')
//   this.age = age
// }
// parent.prototype = new person('老王')
// parent.prototype.getAge = function(){
//   alert(this.age)
// }

// var result = new person('小明')
// result.getName();
// result.friends.push('阿花');
// console.log(result.friends)

// var result1 = new parent(22);
// result1.getName();
// result1.getAge();
// console.log(result1.friends)
//4、寄生组合继承
// 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
// 缺点：堪称完美，但实现较为复杂
// function person(name){
//   this.name = name;
//   this.friends = ['小红','小花'];
// }
// person.prototype.getName = function(){
//   alert(this.name);
// }

// function parent(age){
//   person.call(this,'老王')
//   this.age = age
// }
// (function(){//自定义一个新的构造函数作为类似中间件，先用定义的原型指向父类的原型 这样新的原型上的就有父类原型
//            //然后子类原型指向这个新构造函数的实例  就完成了继承 避免了父类的二次实例化
//    var newObj = function(){}
//    newObj.prototype = person.prototype;
//    parent.prototype = new newObj();
// })()
// parent.prototype.getAge = function(){
//   alert(this.age)
// }

// var result = new parent(33);
// result.getName();
// result.getAge();

//es6对象继承方式
class person{
  constructor(name){//属性需要传的参数 写在constructor （）里
    this.name = name;
    this.friends = ['小红','小花']
    //constructor 里都是类的属性
  }
  //constructor 外写的是 类的方法  类似传统的prototype
  getName(){
    alert(this.name)
  }
}

class parent extends person {//通过extends 来继承父类
  constructor(name,age){//把父类需要的参数传进来 name
    super(name)//super相当于以前的call改变this指向  同时传入父类需要的参数 name
    this.age = age;
  }
  getAge(){
    alert(this.age)
  }
}

var test = new parent('小明',22);
test.getName();
test.getAge();
///////////////////////关于对象的继承补充知识
一个对象原型 function father(){...}
一个对象的实例  var f = new father()
实例上的 __proto__ 属性  对应的是  原型上的原型链  father.prototype
两者是同一个引用
f.__proto__ === father.prototype   => true;

实例的constructor 属性   对应的是  这个对象的原型
f.constructor === father   => true

**********************************************************************************
//es6解构***** 解构赋值可以把对象object 或 数组array  对应的变量里的某一对应项解构出某项的值
//解构会把数据隐式转换成对象或数组  然后进行解构操作 ---- undefined和null不可以会报错
/*数组的解构*/
//一般的解构赋值
var arr = [1,2,3,4]
var [a,b] = arr;
console.log(a);//1
console.log(b);//2
//复杂的结构赋值
var arr2 = [1,2,3,[4,5,[6]]]
var [, , ,[, ,[g]]] = arr2
console.log(g)//6
//与扩展符号...结合使用
//*扩展符
var arr3 = [1,2,3,4];
var arr4 = [5,6,7];
var narr = [...arr3,...arr4];
console.log(narr) //[1,2,3,4,5,6,7]

var arr5 = [1,2,3,4,5,6,7];
var [aa,bb,...cc] = arr5;
console.log(aa)//1
console.log(bb)//2
console.log(cc)//[3,4,5,6,7]
//可以给变量赋一个默认值
var arr6 = [1,undefined,undefined,2,null];
var [w,x=2,y,z=1,u=33] = arr6;
console.log(w)//1
console.log(x)//2
console.log(y)//undefined
console.log(z)//2
console.log(u)//null  null会被看作是一个对象 而覆盖默认值
//交换变量
let s = 12;
let sd = 15;
[s,sd] = [sd,s];
console.log(s);//15
console.log(sd);//12

/*对象的解构*/
//一般使用
var obj = {
  name:'小明',
  age:12
}
var {name,age} = obj;
console.log(name);//小明
console.log(age)//12
//复杂的例子
var obj1 = {
   status:'ok',
   data:[{
        username:'huwei',
        password:123456,
        nick:'yuki'
      },{
        username:'hw',
        password:33332,
        nick:'mavis'
      }]
}
var {data:[ass,{nick:uname}]} = obj1
console.log(ass);//{username:'huwei',password:123456,nick:'yuki'}
console.log(uname)//'mavis'
//结合扩展运算符
let obj2 = {
  id:1, name:'huwei',age:33
}
let {id:sid,...oth} = obj2
console.log(sid);//1
console.log(oth);//{name:"huwei",age:33}
//如何对已经申明了的变量进行对象的解构赋值
let ages;
const obj3 = {
    name:'小明',
    age:22
};
//{ ages } = obj3;    // 这样是会报错的，因为这里的{}被认为是一个块级作用域
({ ages } = obj3);  // <= 解决办法
console.log(ages)                // 不过，最好还是在声明的同时进行解构赋值如何对已经申明了的变量进行对象的解构赋值
// 默认值
let girlfriend = {
    gname: "小红",
    gage:22
};
let {gname="小明",gage,glike='游泳'} = girlfriend;
console.log(gname)//小红   如果解构值不是undefined,解构会覆盖默认值

/*解构字符串*/
const str = "I am the bone of my sword"; // 我是剑骨头
const [sa, sb, sc, ...soth] = str;
console.log(sa);     // "I"
console.log(sb);     // " "
console.log(sc);     // "a"
console.log(soth);   // ["m", " ", "t", "h", "e", " ", "b", "o", "n", "e", " ", 
                    // "o", "f", " ", "m", "y", " ", "s", "w", "o", "r", "d"]

//let {ats} = undefined//会报错  因为不能转成对象型数据进行解构
//let [ats] = null //会报错  因为不能转成对象型数据进行解构
//let [ats] = 6666//数字也会报错
//总结：只有三中数据形式可以进行解构操作：对象，数组，字符串
/***********************************************************************************************/
//let 和 const

在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围。
let增加了块级作用域
let不能像var一样变量提升，用let声明的变量，不存在变量提升。而且要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。
let不允许在相同作用域内，重复声明同一个变量。否则报错：Uncaught SyntaxError: Identifier 'XXX' has already been declared,var则可以，规则是同一作用域里，后命名的覆盖前面的
目的是让js代码更规范和安全

let表示声明变量，而const表示声明常量，两者都为块级作用域；const 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了：
const a = 1
a = 0 //报错
如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行：
const student = { name: 'cc' }

student.name = 'yy';// 不报错
student  = { name: 'yy' };// 报错
/**********************************************************************************************/
//模板字符串
在ES6之前，我们往往这么处理模板字符串：
通过“\”和“+”来构建模板
$("body").html("This demonstrates the output of HTML \
content to the page, including student's\
" + name + ", " + seatNumber + ", " + sex + " and so on.");

而对ES6来说

基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定；
ES6反引号(``)直接搞定
$("body").html(`This demonstrates the output of HTML content to the page, 
including student's ${name}, ${seatNumber}, ${sex} and so on.`);
/**********************************************************************************************/
//箭头函数（Arrow Functions）
ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体；

箭头函数最直观的三个特点。

1不需要 function 关键字来创建函数 x=>{alert(x)}  ====> function(x){alert(x)}
2省略 return 关键字  x=>x+1   ====>  function(x){return x+1}
3继承当前上下文的 this 关键字 自己没有this 会去上一层找this  解决一些回调中this指向了window的问题 例如setTimeout
/***********************************************************************************************/
//函数的参数默认值
// ES6之前，当未传入参数时，text = 'default'；
function printText(text) {
    text = text || 'default';
    console.log(text);
}

// ES6；
function printText(text = 'default') {
    console.log(text);
}

printText('hello'); // hello
printText();// default
/************************************************************************************************/
Spread / Rest 操作符
Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。
当被用于迭代器中时，它是一个 Spread 操作符：
function foo(x,y,z) {
  console.log(x,y,z);
}
 
let arr = [1,2,3];
foo(...arr); // 1 2 3
当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：
function foo(...args) {
  console.log(args);
}
foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
可以巧妙的获取argument数组
/**********************************************************************************************/
for … of循环是ES6引入的新的语法，用for … of循环遍历集合

for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义
var arr = [1,2,3]
for (var value of arr){
  console.log(value);
}//输出 1，2，3

for...in 循环
for...in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。

for (var key in arr){
  console.log(key);
}//输出 0，1，2
/**********************************************************************************************/
es6模块化
export 导出模块

import 引入模块

a.js
export let a = 1;

b.js
import {a} from './a.js'   a  /或者/ import * as b from './a.js'  b.a
as关键字
编程的同学对as都容易理解，简单的说就是取一个别名。export中可以用，import中其实可以用：

// a.js
var a = function() {};
export {a as fun};

// b.js
import {fun as a} from './a';
a();

默认导出  export default {a:1}

import any from './a.js'
any.a //1
/***********************************************************************************/
ECMAScript 5 为 JavaScript 添加了大量新的对象方法，如下
Object.defineProperty(object, property, descriptor) // 添加或更改对象属性 vue实现双向数据绑定的基础
Object.defineProperties(object, descriptors) // 添加或更改多个对象属性
Object.keys(object) // 以数组返回所有可枚举的属性
Object.freeze(object) // 防止对对象进行任何更改
Object.isFrozen(object) // 如果对象被冻结，则返回 true
Object.getOwnPropertyDescriptor(object, property) // 访问属性
Object.getOwnPropertyNames(object) // 以数组返回所有属性
Object.create(object,[descriptors])  //以指定对象为原型创建新的对象

es6
Object.assign(obj1,obj2) //合并obj1,obj2对象 返回一个新的对象
Object.is(value1,value2) //value1 需要比较的第一个值value2 需要比较的第二个值
                           方法判断两个值是否是相同的值 不同于== 和=== 这个相同指的是完全相同
Object.keys()
Object.values()


/********************************************************************************/
//判断Array的6种办法
1. instanceof 操作符判断
用法：arr instanceof Array
instanceof 主要是用来判断某个实例是否属于某个对象
let arr = [];
console.log(arr instanceof Array); // true

2.对象构造函数的 constructor判断
用法：arr.constructor === Array
Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数
let arr = [];
console.log(arr.constructor === Array); // true

3.Array 原型链上的 isPrototypeOf
用法：Array.prototype.isPrototypeOf(arr)
Array.prototype  属性表示 Array 构造函数的原型
其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。
let arr = [];
console.log(Array.prototype.isPrototypeOf(arr)); // true

4.Object.getPrototypeOf
用法：Object.getPrototypeOf(arr) === Array.prototype
Object.getPrototypeOf() 方法返回指定对象的原型

所以只要跟Array的原型比较即可
let arr = [];
console.log(Object.getPrototypeOf(arr) === Array.prototype); // true

5.Object.prototype.toString
用法：Object.prototype.toString.call(arr) === '[object Array]'
虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。
let arr = [];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true

6.Array.isArray
用法：Array.isArray(arr)
ES5中新增了Array.isArray方法,IE8及以下不支持
let arr = [];
console.log(Array.isArray(arr)); // true

/*************************************************************************************/
//js中遍历数组的方法
1.第一种最常用的：for循环

 for(j = 0; j < arr.length; j++) {
    break;    //终止循环
    continue;  //跳过本次循环
    return; // return所在函数
  } //对于数组较大时，优化比较明显；
  //for循环只能遍历数组, 不能遍历对象.

2.第二种：foreach
arr.forEach(function(e){  
   
});
//forEach本身无法跳出所以循环，可采用将forEach放入try{},catch{},手动抛出异常的方式
//forEach无法遍历对象，低版本ie不支持
//forEach无法使用break，continue跳出循环，使用return时，效果和在for循环中使用continue一致

3.for ……in
var arr = new Array("first", "second", "third") 
for(var item in arr) {
document.write(arr[item]+",");
}//for……in 的效率比较低，for in主要用于遍历对象属性
//for...in 遍历数组的缺点：
数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。
for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
某些情况下，for…in循环会以任意顺序遍历键名。

4.map 遍历
arr.map(function(n){  
   
});//该方法只支持数组 map方法使用其提供函数的每次返回结果生成一个新的数组.

5.第五种：for……of 遍历（需要ES6支持）
for(let value of arr) {  
   
});
//es6 新推出的 for...of 循环方式，性能和 for 循环差不多，推荐使用 for...of 遍历数组和对象
for、map是比较常用的两种方法，性能也还行。
/**************************************************************************************/
//算法： 排序的几种方法
//冒泡排序
// function maopao(arr){
//   for (var i = 0; i<arr.length; i++){
//     for(var j=0; j<arr.length-1-i;j++){//因为每次冒泡都把最大放到最后了  所以第二次遍历 可以不用遍历后面的i项
//        if(arr[j]>arr[j+1]){
//           var temp = arr[j];
//           arr[j] = arr[j+1];
//           arr[j+1] = temp;
//        }
//     }
//   }
//   return arr
// }
//选择排序
// function selectSort(arr){
//   var minIndex,temp
//   for(var i = 0; i<arr.length;i++){
//       minIndex = i
//       for(var j=i;j<arr.length;j++){//寻找i以后的项
//          if(arr[j]<arr[minIndex]){//找出比当前i索引下的值小的j索引  保存到变量
//            minIndex = j
//          }
//       }
//       temp = arr[minIndex]; //把找到最小的j索引的值  替换 当前第i项   这样就保证每次都把最小的放到前面了
//       arr[minIndex] = arr[i];
//       arr[i] = temp
//   }
//   return arr
// } 
//插入排序（Insertion Sort）
// function insertionSort(arr) {
//   var preIndex,temp,len = arr.length;
//   for(var i=1;i<len;i++){
//      preIndex = i-1;
//      temp = arr[i];
//      while(preIndex>=0&&arr[preIndex]>temp){//进入循环的条件 前一项值大于当前项  
//        arr[preIndex+1] = arr[preIndex]     //就把当前项替换成前一项  
//        preIndex--    //然后继续查下一个是不是符合循环条件
//      }
//      arr[preIndex+1] = temp //跳出循环时的preIndex+1项是没有值的因为比temp大的都移到前面项去了把记录的temp填入
//   }
//   return arr

// } 







