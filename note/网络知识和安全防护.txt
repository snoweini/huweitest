HTTP协议
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP是基于TCP/IP协议通信协议来传递数据（HTML文件, 图片文件, 查询结果等）。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。

Http的特点
1.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
2.灵活：HTTP允许传输任意类型的数据对象。
3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4.无状态：HTTP协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存。任何两次请求之间都没有依赖关系。直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的。协议本身并不保留之前一切的请求或 响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。


Http报文
Http报文包括请求报文和响应报文两大部分，其中请求报文由请求行（request line）、请求头（header）、空行和请求体四个部分组成。而响应报文由状态行、响应头部、空行和响应体四个部分组成。接下来我们了解下请求报文的各个部分及其作用。
1.请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。
POST  /chapter17/user.html HTTP/1.1
POST代表请求方法，/chapter17/user.html表示URI，HTTP/1.1代表协议和协议的版本。
2.请求头由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。
请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：
Host表示主机名，虚拟主机；
Connection，HTTP/1.1增加的，使用keepalive，即持久连接，一个连接可以发多个请求；
User-Agent，请求发出者，兼容性以及定制化需求。
3.最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。
4.请求体，可以承载多个请求参数的数据


HTTP请求方法
GET请求指定的页面信息，并返回实体主体。
HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。
PUT从客户端向服务器传送的数据取代指定的文档的内容。
DELETE请求服务器删除指定的页面。


GET与POST区别
GET在浏览器回退时是无害的，而POST会再次提交请求
GET请求会被浏览器主动缓存，而POST不会，除非手动设置
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
GET请求在URL中传送的参数是有长度限制的，而POST没有限制
GET参数通过URL传递，POST放在Request body中

Http状态码
状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作  //304缓存
4xx：客户端错误--请求有语法错误或请求无法实现  //404找不到文件
5xx：服务器端错误--服务器未能实现合法的请求  //500服务端程序错误

HTTPS工作原理
什么是HTTPS
HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。
HTTPS主要作用是：
对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
对网站服务器进行真实身份认证。

为什么需要HTTPS
在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。
*HTTP协议存在的哪些问题：
1.通信使用明文（不加密），内容可能被窃听
由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。
HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。
2.无法证明报文的完整性，所以可能遭篡改
所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。
换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。
3.不验证通信方的身份，因此有可能遭遇伪装
HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下


HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。
反观HTTPS协议，它比HTTP协议相比多了以下优势:
1.数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
2.数据完整性：内容传输经过完整性校验
3.身份认证：第三方无法伪造服务端（客户端）身份

HTTP 与 HTTPS 的区别
HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
HTTPS需要用到SSL证书，而HTTP不用;
HTTPS标准端口443，HTTP标准端口80;
HTTPS基于传输层，HTTP基于应用层;
HTTPS在浏览器显示绿色安全锁，HTTP没有显示。

为何不所有的网站都使用HTTPS
既然HTTPS那么安全可靠，那为何不所有的Web网站都使用HTTPS？
首先，很多人还是会觉得HTTPS实施有门槛，这个门槛在于需要权威CA颁发的SSL证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。
其次，HTTPS普遍认为性能消耗要大于HTTP，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在SLB或CDN，来解决此问题。
除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。
最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS部署趋势是由社会、企业、政府共同去推动的。


计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。
TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。
TCP/IP 模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。
链路层：负责封装和解封装 IP 报文，发送和接受 ARP/RARP 报文等。
网络层：负责路由以及把分组报文发送给目标网络或主机。
传输层：负责对报文进行分组和重组，并以 TCP 或 UDP 协议格式封装报文。
应用层：负责向用户提供应用程序，比如 HTTP、FTP、Telnet、DNS、SMTP 等。


HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。

在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。
二进制传输
HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。
多路复用
在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。
帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。
Header 压缩
在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。
在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
服务端 Push
在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。
可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。



QUIC
这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。


DNS
DNS 的作用就是通过域名查询到具体的 IP。
因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。



从输入 URL 到页面加载完成的过程
1.首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来

2.接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了

3.TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据

4.数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件

5.首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错

6.浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件

7.文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。

8.初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件

9.CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

10.在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了




/***********************网络安全问题***************************/

常见的Web漏洞(包括XSS CSRF 劫持等)

XSS(Cross Site Scripting)
可以通俗的总结为：想尽一切办法，将你的脚本内容在目标网站中的目标客户的浏览器上解析执行。
跨站脚本 (Cross-Site Scripting, XSS) 是一种代码注入方式, 为了与 CSS 区分所以被称作 XSS. 早期常见于网络论坛, 起因是网站没有对用户的输入进行严格的限制, 使得攻击者可以将脚本上传到帖子让其他人浏览到有恶意脚本的页面, 其注入方式很简单包括但不限于 JavaScript / VBScript / CSS / Flash 等.

1.XSS类型

反射性XSS
存储性XSS
DOM XSS

demo1：DOM型XSS漏洞
http://safe.hack.com/xss/demo1/#document.write("<script/src=//safe.hack.com/xss/demo1/alert.js><\/script>");

demo2：反射型XSS漏洞1
http://safe.hack.com/xss/demo2/reflect1.php?x=%3Cscript%3Ealert(1)%3C/script%3E

demo3: 存储型XSS漏洞
http://safe.hack.com/xss/demo2/reflect2.php?x=data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pPC9zY3JpcHQ%2b

有何危害？

挂马
盗取用户cookie
钓鱼攻击
恶意篡改数据
劫持用户行为
蠕虫攻击
如何防护？

HTML标签之间：编码转换
HTML属性：使用引号包裹属性，且对内容属性进行转码
javaScript ：小心输入的 闭合之前的script标签
XSS：过滤js伪协议，表达式及各种变形 @import及各种变形
URL：对特殊字符使用%HH形式编码。过滤data:/javaScriopt 等伪协议
X-XSS-Protection 

防范与过滤
1.输入编码过滤:对于每一个输入，在客户端和服务器端验证是否合法字符，长度是否合法，格式是否正确,对字符进行转义.非法字符过滤.
2.输出编码过滤:对所有要动态输出到页面的内容，进行相关的编码和转义.主要有HTML字符过滤和转义,JS脚本转义过滤.url转义过滤.
3.设置http-only,避免攻击脚本读取cookie.


2.XSRF
什么是XSRF(Cross-site request forger) ?

CSRF攻击攻击原理及过程如下：

用户C打开浏览器，防护受信用的网站A输入用户名和密码请求登陆网站
在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登陆网站A成功，可以正常发送请求到网站A
用户未退出A之前，在同一浏览器中，打开一个TAB页访问网站B
网站B接受到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A
浏览器在没收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发送请求。网站A并不知道该请求其实是B发起的，所以会根据用户的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 

攻击类型
HTML CSRF 攻击
JSON HiJacking攻击
FLash CSRF 攻击

demo1：HTML攻击 
1、safe.hack.com 网站登录
http://safe.hack.com/csrf/demo1/login.php?pwd=123

2、safe.hack.com API访问
http://safe.hack.com/csrf/demo1/safe.php?action=add

3：danger.hack.com 钓鱼网站
http://danger.hack.com/csrf/demo1/danger.html

demo2：JSON 劫持攻击
1、safe.hack.com 网站登录
http://safe.hack.com/csrf/demo1/login.php?pwd=123

2、safe.hack.com API访问
http://safe.hack.com/csrf/demo2/response.php?cb=__callback

3、danger.hack.com 钓鱼网站
http://danger.hack.com/csrf/demo2/index.html


有何危害？

修改目标网站用户数据
盗取用户隐私数据
传播SCRF蠕虫
其他攻击方法的辅助手段

如何防护？

效验Referer
限制Session Cookie的声明周期
使用验证码
使用一次性Token
X-Content-Security-Policy(内容安全政策)
预防:
1.在 HTTP 头中自定义属性并验证
2.检查 CSRF token.
3.cookie中加入hash随机数.
4.通过检查来过滤简单的 CSRF 攻击, 主要检查一下两个 header:
Origin Header
Referer Header

什么是劫持？
可以通俗的总结为：将你想看的内容，替换为劫持者想让你看的内容

常见劫持类型
HTTP劫持
当你打开360当好的页面时，右下角出现了运营商的广告
DNS劫持
当你输入360导航网站时，出现的是hao123的页面
页面操作劫持
当你以为点击的是A页面的普通链接，但实际上点击的可能是支付宝的登陆按钮 


中间人攻击
中间人 (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制. 在中间人攻击中, 攻击者可以拦截通讯双方的通话并插入新的内容.

目前比较常见的是在公共场所放置精心准备的免费 wifi, 劫持/监控通过该 wifi 的流量. 或者攻击路由器, 连上你家 wifi 攻破你家 wifi 之后在上面劫持流量等.

对于通信过程中的 MITM, 常见的方案是通过 PKI / TLS 预防, 及时是通过存在第三方中间人的 wifi 你通过 HTTPS 访问的页面依旧是安全的. 而 HTTP 协议是明文传输, 则没有任何防护可言.

不常见的还有强力的互相认证, 你确认他之后, 他也确认你一下; 延迟测试, 统计传输时间, 如果通讯延迟过高则认为可能存在第三方中间人; 等等.


SQL/NoSQL 注入
注入攻击是指当所执行的一些操作中有部分由用户传入时, 用户可以将其恶意逻辑注入到操作中. 当你使用 eval, new Function 等方式执行的字符串中有用户输入的部分时, 就可能被注入攻击. 上文中的 XSS 就属于一种注入攻击. 前面的章节中也提到过 Node.js 的 child_process.exec 由于调用 bash 解析, 如果执行的命令中有部分属于用户输入, 也可能被注入攻击.

防范手段
1.给表名/字段名加前缀 (避免被猜到)
2.报错隐藏表信息 (避免被看到, 12306 早起就出现过的问题)
3.过滤可以拼接 SQL 的关键字符
4.对用户输入进行转义
5.验证用户输入的类型 (避免 limit, order by 等注入)

等...


DDOS
DDoS即Distributed Denial of Service，分布式拒绝服务。也就是攻击者借助或者利用服务器技术，将多个计算机（肉鸡或僵尸机）联合起来作为攻击平台，对一个或者多个目标服务器，同一时间发送大量垃圾信息，或利用某种干扰信息的方式，导致目标服务器无法及时响应正常用户正常请求，或者直接导致目标服务器宕机，从而无法为正常用户提供服务的一种攻击行为。

攻击方式:
1.端口扫描攻击
2.ping洪水（flooding）攻击
3.SYN洪水（flooding）攻击
4.FTP跳转攻击

防范手段:
1.保证服务器系统的安全,确保服务器软件没有任何漏洞，防止攻击者入侵。
2.确保服务器采用最新系统，并打上安全补丁。
3.在服务器上删除未使用的服务，关闭未使用的端口。
4.对于服务器上运行的网站，确保其打了最新的补丁，没有安全漏洞。
5.隐藏服务器的真实IP地址






