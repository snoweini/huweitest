第一课：
react脚手架
具备自己开发的独立思想（mvc：Model View Controller）
  -> 划分组件开发
  -> 基于路由的SPA单页面开发
  -> 基于ES6来编写代码（最后上线时，我们需要把ES6编译成ES5=>基于Babel来完成编译）
  -> 可能用到Less/Sass等，我们也需要使用对应插件把他们也编译
  -> 最后为了优化性能（减少HTTP请求次数），把js css进行合并压缩
  ->...
  webpack来完成以上组件合并，js/css编译压缩

  前端工程化开发：
   ->基于框架的组件化/模块化开发
   ->基于webpack的自动部署

  但是配置webpack是一个相对复杂的工作，我们需要自己安装很多的包
  还需要自己写相对复杂的配置
  如果我们有一个插件，基于它可以快速构建一套完整的自动化工程项目结构
  那么有助于提高开发效率，=>“脚手架“
     VUE:VUE-CLI
     REACT:CREATE-REACT-APP

第二课：
【create-react-app 的使用】
  > $ npm install create-react-app -g
    把模块安装在全局环境下（目的： 可以使用命令操作）
    mac电脑安装需要加sudo 否则没有权限
  
  > $ create-react-app [项目名称]
    基于脚手架命令，创建出一个基于react的自动化/工程化项目目录
    和npm发包规则一样，项目名称不能出现：大写字母、中文汉字、特殊符号
    （-或者_是可以的）等

【脚手架生产目录的一些内容】
    node_modules 当前项目中依赖的包都安装在这里
       .bin  本地项目中可执行命令， 在package.json的scripgts中
       配置对应的脚本即可(其中有一个就是 react-scripts命令)

    public  存放当前项目的html页面（单页面应用放一个index.html即可，多页面
    根据自己需求放置需要的页面）
    在React框架中，所有的逻辑都是在js中完成的（包括页面结构的创建）
    如果想给当前页面导入一些css样式或者img图片等内容，我们有两种方式
       1.在js中基于es6 Module模块规范，使用import导入这样webpack合并
       时会把导入的资源文件等插入到页面的结构中（绝对不能在js管控的结构中
       通过相对目录./或者../导入资源,因为在webpack编译的时候，地址就不再是
       之前的相对地址)
       2.如果不想在js导入（js导入资源会基于webpack编译）资源手动在html里导入
       但是html最后也要基于webpack编译，导入地址也不建议写相对地址，二十使用
       %PUBLIC_URL%写成绝对地址

    src  项目结构中最主要的目录，因为后期所有的js、路由、组件都是放在这里。
    包括需要编写的css或者图片等
        index.js是当前项目入口文件

        .gitignore  Git提交时忽略文件

        package.json 当前项目配置清单
          "dependencies": {
            "react": "^16.13.1",
            "react-dom": "^16.13.1",
            "react-scripts": "3.4.1"
          },
        自动帮我们安装了 react/react-dom/react-scripts
           react-scripts集成了webpack需要的内容
               ->Babel 一套
               ->css处理 一套
               ->eslint 一套
               ->webpack 一套
               ->其他
            没有less/sass的处理内容（项目中使用less，我们需要自己额外安装)


        ---------
        "scripts": {
          "start": "react-scripts start",
          "build": "react-scripts build",
          "test": "react-scripts test",
          "eject": "react-scripts eject"
        },
        可执行脚本“$ npm run start / $ yarn start"
            start: 开发环境下， 基于webpack编译处理，最后可以预览当前开发项目
            （在webpack中安装了dev-server插件，基于这个插件会自动创建一个服务【端口号
            默认是3000】，webpack会帮我们自动打开浏览器，并且展示我们的页面，能监听我们的代码
            改变，如果改变了，webpack会自动重新编译，并且刷新浏览器来重新渲染）

            build：项目需要部署到服务器上，我们先用build把项目整体打包，完成后会在
            项目中生成一个build文件夹，这个文件夹中包含了所有编译的内容，我们把它上传到服务器
            即可。服务器上进行部署的时候，不需要安装任何模块了（因为webpack已经把需要的
            的内容都打包到一个js里了） 
 
 第三课

2.React脚手架的深入解析
  create-react-app脚手架为了让结构目录清晰，把安装的webpack及配置文件集成
  react-scripts模块中，放到了node_modules中

  但是真实项目中，我们需要在脚手架默认安装的基础上，额外安装一些我们需要的
  模块，例如：react-router-dom/axios...  再比如less/less-loader...
  
    情况1：如果我们安装其他组件，但是安装成功后不需要修改webpack配置项
          此时我们直接安装，并且调取使用即可

    情况2: 我们安装的插件是基于webpack处理的，也就是需要把安装的模块webpack中
    重新修改webpack配置项
         =>首先需要把隐藏的node_modules中的配置项暴露到项目中
           >yarn eject
           首先会提示是否执行eject操作，操作不可逆，暴露就无法隐藏了

           如果当前的项目基于git管理，在执行eject的时候，如果还没有
           提交历史区的内容，需要先提交历史区，然后才可以eject 否则报错

         =>再去修改对应的配置项即可
           一旦暴露后，项目目录多了两个文件夹：
           config 存放的是webpack的配置文件 
              webpack.config.dev.js 开发环境配置项   yarn start
              webpack.config.prod.js  生产环境下的配置  yarn build
           scripts 存放的是可执行脚本的js文件
              start.js  yarn start 执行的就是这个js
              build.js  yarn build 执行的就是这个js

          package.json 中的文件也改变了

          举个例子：配置需要的less
            $ yarn add less less-loader

            less是开发和生产环境下都需要的
            ...
            {
               test: /\.(css|less)$/,
               use:{
                 require.resolve('style-loader'),
                 ...
                 {
                   loader: require.resolve('less-loader')
                 }
               }
            }
            ...
            



    我们预览项目的时候，也是先基于webpack编译，把编译后的内容放到浏览器中运行
    所以如果项目中使用了less，我们需要修改webpack配置，在配置中加入less编译
    工作这样后期预览项目，首先基于webpack把less编译为css 然后
    再呈现到页面中


    $ set HTTPS=true&&npm start  切换成https协议模式预览
    设置环境变量HTTPS的值

    $ set PORT=63341&&yarn start  修改端口号
    //process.env.PORT


第四课
React & react-dom
  
  【渐进式框架】
     一种最流行的框架设计思想，一般框架中都包含很多内容，这样导致
     框架的体积过于臃肿，拖慢加载速度。真是中使用框架不一定使用所有
     功能，此时我们应该把框架的功能拆分，用户想用什么，让其自由组合即可

     全家桶：渐进式框架n多部分的组合
     vue全家桶：vue-cli/vue/vue-router/vuex/axios(fetch)/elementui(vant)
     REACT全家桶: create-react-app/react/react-dom/react-router/redux
                /react-redux/axios/ant/dva/saga/mobx...

       1.react: REACT框架的核心部分，提供了Component类供我们进行组件开发
          提供了钩子函数（生命周期函数：所有的生命周期函数都是基于回调函数完成）

       2.react-dom：把jsx语法（REACT独有语法）渲染为真实dom（能够放到页面中展示的
       结构都叫做真实dom）的组件

       ReactDOM.render({jsx},{container},{callback}) //把jsx元素渲染到页面中
        jsx:react虚拟元素
        container 容器 我们把元素放到页面中的哪个容器中
        callback  当内容放到页面后触发回调函数

        JSX:REACT独有的语法  JAVASCRIPT + XML(HTML)
            和我们之前自己拼接的html字符串类似，都是把html结构代码和
            js代码混合在一起，但是它不是字符串

          1.不建议我们把jsx直接渲染到body中，而是放在自己创建的一个容器中
            一般我们都放在一个id为root的div中

          2.在jsx中出现{}是存放js的，js代码执行完成有返回结果（js表达式）
            ->不能直接放一个对象数据类型的值（对象（除了给style赋值）、数组（数组如果都是基本值是可以的或者是jsx元素也可以）、函数都不行）
            ->可以是基本类型值（布尔类型不显示也不报错、null,undefined
            代表空）
            ->循环判断的语句都不支持，但是支持三元运算符（？ ：）

          3.循环数组创建jsx元素（一般基于数组的map方法完成），需要给创建的元素设置唯一的key值（当前循环内唯一即可）

          4.只能出现一个根元素

          5.给元素设置样式类用的是className不是class

          6.style中不能直接写样式字符串，需要基于一个样式对象来遍历赋值

          let data = "yuki"
ReactDOM.render(<div>hello,world {data}</div>,document.getElementById('root'));

======================================
第六课
把jsx（虚拟dom）变成真实dom
import ReactDOM, {render} from 'react-dom';
//从react-dom导入一个ReactDOM，逗号后面的内容是把ReactDOM这个对象进行解构
<=>import {render} from 'react-dom';

   jsx渲染机制
      1.基于BABEL中的语法解析模块(BABEL-PRESET-REACT)把jsx语法
      编译为React.createElement(...)结构
网址：https://babeljs.io/repl
          React.createElement("h1", {
            id: "titleBox",
            className: "title",
            style: {
              color: 'red'
            }
          }, "\u6211\u662F\u6807\u9898");
      
      2.执行React.createElement(type, props, children),创建一个对象（虚拟dom）
         type: 'h1'
         props:{
           id:'titleBox'
           className:'title'
           style...
           children:'珠峰培训' =>存放元素中的内容
         }
         ref: null
         key: null
         ...
         __proto__: Object.prototype


   3.ReactDOM.render(JSX语法最后生成对象，容器)，基于RENDER方法把生成的对象动态创建为DOM元素，插入到指定的容器中。







       



















 





  react-scripts  集成了webpack需要的配置
     Babel一套
     css处理一套
     eslint一套
     webpack一套
   没有less  sass处理

  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },可执行脚本


React 和 React-dom
[渐进式框架]

